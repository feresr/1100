/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import * as THREE from "three";
import React, { useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { useSpring, animated, Spring } from "@react-spring/three";

export default function Model({ ...props }) {
  const group = useRef();
  const { nodes, materials } = useGLTF("./1100.gltf");
  const { mouse } = useThree();
  const { spring } = useSpring({ scale: props.game.restart ? 1 : 0 });

  let spinning = false;
  let spinningt = 0;

  useFrame(({ clock }) => {
    if (props.game.restart) {
      console.log("Restarting....");
      spinning = true;
      spinningt = 0;
    }

    const t = clock.getElapsedTime();
    if (spinning) {
      // rotate
      group.current.rotation.y = THREE.MathUtils.lerp(
        group.current.rotation.y,
        2 * Math.PI + 0.6 * Math.sin(mouse.x),
        spinningt * spinningt * spinningt
      ) 
      spinningt += 0.01;
      if (spinningt > 1) {
        spinning = false;
      }
    } else {
      group.current.rotation.y = 0.6 * Math.sin(mouse.x);
    }
    group.current.rotation.x = 0.4 * Math.sin(-mouse.y);
    // float
    group.current.rotation.z = THREE.MathUtils.lerp(
      group.current.rotation.z,
      Math.sin(t / 4) / 4,
      0.1
    );
    group.current.position.y = THREE.MathUtils.lerp(
      group.current.position.y,
      Math.sin(t) / 5,
      0.1
    );
  });
  materials.Screen.map = props.texture;
  materials.Screen.emissiveMap = props.texture;
   materials.Screen.color = 0;
  console.log(materials.Phone)
  return (
    <group scale={1} ref={group} {...props} dispose={null}>
      <mesh geometry={nodes.Cube002.geometry} material={materials.Phone} />
      <mesh geometry={nodes.Cube002_1.geometry} material={materials.Screen} />
    </group>
  );
}

useGLTF.preload("/1100.gltf");
